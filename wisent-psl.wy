%languagemode psl-mode

;; The default goal.
%start goal
;; Alternate goals needed for re-parse.
%start function_def
%start variable_def

;;    - Needed by EXPANDFULL clauses
%start function_parameters

;; -----------------------------
;; Block & Parenthesis terminals
;; -----------------------------
%type  <block>       ;;syntax "\\s(\\|\\s)" matchdatatype block

%token <block>       PAREN_BLOCK "(LPAREN RPAREN)"
%token <block>       BRACE_BLOCK "(LBRACE RBRACE)"
%token <block>       BRACK_BLOCK "(LBRACK RBRACK)"

%token <open-paren>  LPAREN      "("
%token <close-paren> RPAREN      ")"
%token <open-paren>  LBRACE      "{"
%token <close-paren> RBRACE      "}"
%token <open-paren>  LBRACK      "["
%token <close-paren> RBRACK      "]"

;; ------------------
;; Operator terminals
;; ------------------
%type  <punctuation> ;;syntax "\\(\\s.\\|\\s$\\|\\s'\\)+" matchdatatype string

%token <punctuation> PLUS       "+"
%token <punctuation> PLUSPLUS    "++"
%token <punctuation> PLUSEQ     "+="

%token <punctuation> MINUS      "-"
%token <punctuation> MINUSMINUS  "--"
%token <punctuation> MINUSEQ    "-="

%token <punctuation> LT         "<"
%token <punctuation> GT         ">"

%token <punctuation> PERIOD     "."
%token <punctuation> COLON      ":"
%token <punctuation> SEMICOLON	";"
%token <punctuation> COMMA      ","
%token <punctuation> ASSIGN     "="
%token <punctuation> AT         "@"


;; -----------------
;; Literal terminals
;; -----------------
%type  <string>      ;;syntax "\\s\"" matchdatatype sexp
%token <string>      STRING_LITERAL

%type  <number>      ;;syntax semantic-lex-number-expression
%token <number>      NUMBER_LITERAL

%type  <symbol>      ;;syntax "\\(\\sw\\|\\s_\\)+"
%token <symbol>      NAME

%token <symbol>      BOOLEAN_LITERAL "\\`false\\'"
%token <symbol>      BOOLEAN_LITERAL "\\`true\\'"

;; -----------------
;; Keyword terminals
;; -----------------
%type  <keyword> ;;syntax "\\(\\sw\\|\\s_\\)+" matchdatatype keyword

%keyword IF          "if"
%put     IF summary
"Start 'if' conditional statement"

%keyword FOR         "for"
%put     FOR summary
"Start a 'for' loop"

%keyword WHILE       "while"
%put     WHILE summary
"Start a 'while' loop"

%keyword LAMBDA      "lambda"
%put     LAMBDA summary
"Create anonymous function"

%keyword DEFFUN      "deffun"
%put     DEFFUN summary
"Define a new function"

%keyword DEFVAR      "defvar"
%put     DEFVAR summary
"Define a new variable"

%keyword IN      "in"
%put     IN summary
"Specify the scope of a variable or function definition"

%%

goal
  : simple_expr
  | toplevel_expr
  ;

;; simple_expr: small_expr (';' small_expr)* [';']
simple_expr
  : small_expr_list semicolon_opt
  ;

;; small_expr (';' small_expr)*
small_expr_list
  : small_expr
  | small_expr_list SEMICOLON small_expr
  ;

small_expr
  : atom
    (CODE-TAG $1 nil)
  ;

atom
  : NUMBER_LITERAL
  | STRING_LITERAL
  | BOOLEAN_LITERAL
  ;

toplevel_expr
  : function_def
  | variable_def
  ;

function_def
  : DEFFUN NAME function_parameter_list
  ;

function_parameter_list
  : PAREN_BLOCK
    (EXPANDFULL $1 function_parameters)
  ;

function_parameters
  : LPAREN
    ()
  | RPAREN
    ()
  | NAME COMMA
    (VARIABLE-TAG $1 nil nil)
  | NAME RPAREN
    (VARIABLE-TAG $1 nil nil)
  ;

variable_def
  : DEFVAR NAME ASSIGN simple_expr IN simple_expr
  ;

;; [',']
comma_opt
  : ;;EMPTY
  | COMMA
  ;

;; [';']
semicolon_opt
  : ;;EMPTY
  | SEMICOLON
  ;

%%

(define-lex psl-lexer
"Lexer for `psl-mode'"
;;std stuff
  semantic-lex-ignore-whitespace
  semantic-lex-ignore-newline
  semantic-lex-ignore-comments

  ;;stuff generated from the wy file(one for each "type" declaration)
  wisent-psl-wy--<number>-regexp-analyzer
  wisent-psl-wy--<string>-sexp-analyzer

  wisent-psl-wy--<keyword>-keyword-analyzer

  wisent-psl-wy--<symbol>-regexp-analyzer
  wisent-psl-wy--<punctuation>-string-analyzer
  wisent-psl-wy--<block>-block-analyzer

  ;;;;more std stuff
  semantic-lex-default-action
  )
